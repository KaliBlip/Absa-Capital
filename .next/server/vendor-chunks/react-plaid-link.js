"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-plaid-link";
exports.ids = ["vendor-chunks/react-plaid-link"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-plaid-link/dist/index.esm.js":
/*!*********************************************************!*\
  !*** ./node_modules/react-plaid-link/dist/index.esm.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PlaidEmbeddedLink: () => (/* binding */ PlaidEmbeddedLink),\n/* harmony export */   PlaidLink: () => (/* binding */ PlaidLink),\n/* harmony export */   PlaidLinkStableEvent: () => (/* binding */ PlaidLinkStableEvent),\n/* harmony export */   usePlaidLink: () => (/* binding */ usePlaidLink)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction unwrapExports (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar useScript_1 = createCommonjsModule(function (module, exports) {\n\nvar __rest = commonjsGlobal && commonjsGlobal.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.scripts = void 0;\n\n // Previously loading/loaded scripts and their current status\n\n\nexports.scripts = {}; // Check for existing <script> tags with this src. If so, update scripts[src]\n// and return the new status; otherwise, return undefined.\n\nvar checkExisting = function (src) {\n  var existing = document.querySelector(\"script[src=\\\"\" + src + \"\\\"]\");\n\n  if (existing) {\n    // Assume existing <script> tag is already loaded,\n    // and cache that data for future use.\n    return exports.scripts[src] = {\n      loading: false,\n      error: null,\n      scriptEl: existing\n    };\n  }\n\n  return undefined;\n};\n\nfunction useScript(_a) {\n  var src = _a.src,\n      _b = _a.checkForExisting,\n      checkForExisting = _b === void 0 ? false : _b,\n      attributes = __rest(_a, [\"src\", \"checkForExisting\"]); // Check whether some instance of this hook considered this src.\n\n\n  var status = src ? exports.scripts[src] : undefined; // If requested, check for existing <script> tags with this src\n  // (unless we've already loaded the script ourselves).\n\n  if (!status && checkForExisting && src && isBrowser) {\n    status = checkExisting(src);\n  }\n\n  var _c = (0, (react__WEBPACK_IMPORTED_MODULE_0___default().useState))(status ? status.loading : Boolean(src)),\n      loading = _c[0],\n      setLoading = _c[1];\n\n  var _d = (0, (react__WEBPACK_IMPORTED_MODULE_0___default().useState))(status ? status.error : null),\n      error = _d[0],\n      setError = _d[1];\n\n  (0, (react__WEBPACK_IMPORTED_MODULE_0___default().useEffect))(function () {\n    // Nothing to do on server, or if no src specified, or\n    // if loading has already resolved to \"loaded\" or \"error\" state.\n    if (!isBrowser || !src || !loading || error) return; // Check again for existing <script> tags with this src\n    // in case it's changed since mount.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n\n    status = exports.scripts[src];\n\n    if (!status && checkForExisting) {\n      status = checkExisting(src);\n    } // Determine or create <script> element to listen to.\n\n\n    var scriptEl;\n\n    if (status) {\n      scriptEl = status.scriptEl;\n    } else {\n      scriptEl = document.createElement('script');\n      scriptEl.src = src;\n      Object.keys(attributes).forEach(function (key) {\n        if (scriptEl[key] === undefined) {\n          scriptEl.setAttribute(key, attributes[key]);\n        } else {\n          scriptEl[key] = attributes[key];\n        }\n      });\n      status = exports.scripts[src] = {\n        loading: true,\n        error: null,\n        scriptEl: scriptEl\n      };\n    } // `status` is now guaranteed to be defined: either the old status\n    // from a previous load, or a newly created one.\n\n\n    var handleLoad = function () {\n      if (status) status.loading = false;\n      setLoading(false);\n    };\n\n    var handleError = function (error) {\n      if (status) status.error = error;\n      setError(error);\n    };\n\n    scriptEl.addEventListener('load', handleLoad);\n    scriptEl.addEventListener('error', handleError);\n    document.body.appendChild(scriptEl);\n    return function () {\n      scriptEl.removeEventListener('load', handleLoad);\n      scriptEl.removeEventListener('error', handleError);\n    }; // we need to ignore the attributes as they're a new object per call, so we'd never skip an effect call\n  }, [src]);\n  return [loading, error];\n}\n\nexports.default = useScript;\nvar isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';\n});\n\nunwrapExports(useScript_1);\nvar useScript_2 = useScript_1.scripts;\n\nvar lib = createCommonjsModule(function (module, exports) {\n\nvar __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.scripts = exports.default = void 0;\n\n\n\nObject.defineProperty(exports, \"default\", {\n  enumerable: true,\n  get: function () {\n    return __importDefault(useScript_1).default;\n  }\n});\nObject.defineProperty(exports, \"scripts\", {\n  enumerable: true,\n  get: function () {\n    return useScript_1.scripts;\n  }\n});\n});\n\nvar useScript = unwrapExports(lib);\nvar lib_1 = lib.scripts;\n\nvar renameKeyInObject = function renameKeyInObject(o, oldKey, newKey) {\n  var newObject = {};\n  delete Object.assign(newObject, o, _defineProperty({}, newKey, o[oldKey]))[oldKey];\n  return newObject;\n};\n/**\n * Wrap link handler creation and instance to clean up iframe via destroy() method\n */\n\n\nvar createPlaidHandler = function createPlaidHandler(config, creator) {\n  var state = {\n    plaid: null,\n    open: false,\n    onExitCallback: null\n  }; // If Plaid is not available, throw an Error\n\n  if (typeof window === 'undefined' || !window.Plaid) {\n    throw new Error('Plaid not loaded');\n  }\n\n  state.plaid = creator(_objectSpread2(_objectSpread2({}, config), {}, {\n    onExit: function onExit(error, metadata) {\n      state.open = false;\n      config.onExit && config.onExit(error, metadata);\n      state.onExitCallback && state.onExitCallback();\n    }\n  }));\n\n  var open = function open() {\n    if (!state.plaid) {\n      return;\n    }\n\n    state.open = true;\n    state.onExitCallback = null;\n    state.plaid.open();\n  };\n\n  var submit = function submit(data) {\n    if (!state.plaid) {\n      return;\n    }\n\n    state.plaid.submit(data);\n  };\n\n  var exit = function exit(exitOptions, callback) {\n    if (!state.open || !state.plaid) {\n      callback && callback();\n      return;\n    }\n\n    state.onExitCallback = callback;\n    state.plaid.exit(exitOptions);\n\n    if (exitOptions && exitOptions.force) {\n      state.open = false;\n    }\n  };\n\n  var destroy = function destroy() {\n    if (!state.plaid) {\n      return;\n    }\n\n    state.plaid.destroy();\n    state.plaid = null;\n  };\n\n  return {\n    open: open,\n    submit: submit,\n    exit: exit,\n    destroy: destroy\n  };\n};\nvar createPlaid = function createPlaid(options, creator) {\n  var config = renameKeyInObject(options, 'publicKey', 'key');\n  return createPlaidHandler(config, creator);\n};\n\nvar PLAID_LINK_STABLE_URL = 'https://cdn.plaid.com/link/v2/stable/link-initialize.js';\n\nvar noop = function noop() {};\n/**\n * This hook loads Plaid script and manages the Plaid Link creation for you.\n * You get easy open & exit methods to call and loading & error states.\n *\n * This will destroy the Plaid UI on un-mounting so it's up to you to be\n * graceful to the user.\n *\n * A new Plaid instance is created every time the token and products options change.\n * It's up to you to prevent unnecessary re-creations on re-render.\n */\n\n\nvar usePlaidLink = function usePlaidLink(options) {\n  // Asynchronously load the plaid/link/stable url into the DOM\n  var _useScript = useScript({\n    src: PLAID_LINK_STABLE_URL,\n    checkForExisting: true\n  }),\n      _useScript2 = _slicedToArray(_useScript, 2),\n      loading = _useScript2[0],\n      error = _useScript2[1]; // internal state\n\n\n  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null),\n      _useState2 = _slicedToArray(_useState, 2),\n      plaid = _useState2[0],\n      setPlaid = _useState2[1];\n\n  var _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),\n      _useState4 = _slicedToArray(_useState3, 2),\n      iframeLoaded = _useState4[0],\n      setIframeLoaded = _useState4[1];\n\n  var products = (options.product || []).slice().sort().join(',');\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    // If the link.js script is still loading, return prematurely\n    if (loading) {\n      return;\n    } // If the token, publicKey, and received redirect URI are undefined, return prematurely\n\n\n    if (!options.token && !options.publicKey && !options.receivedRedirectUri) {\n      return;\n    }\n\n    if (error || !window.Plaid) {\n      // eslint-disable-next-line no-console\n      console.error('Error loading Plaid', error);\n      return;\n    } // if an old plaid instance exists, destroy it before\n    // creating a new one\n\n\n    if (plaid != null) {\n      plaid.exit({\n        force: true\n      }, function () {\n        return plaid.destroy();\n      });\n    }\n\n    var next = createPlaid(_objectSpread2(_objectSpread2({}, options), {}, {\n      onLoad: function onLoad() {\n        setIframeLoaded(true);\n        options.onLoad && options.onLoad();\n      }\n    }), window.Plaid.create);\n    setPlaid(next); // destroy the Plaid iframe factory\n\n    return function () {\n      return next.exit({\n        force: true\n      }, function () {\n        return next.destroy();\n      });\n    };\n  }, [loading, error, options.publicKey, options.token, products]);\n  var ready = plaid != null && (!loading || iframeLoaded);\n\n  var openNoOp = function openNoOp() {\n    if (!options.token) {\n      console.warn('react-plaid-link: You cannot call open() without a valid token supplied to usePlaidLink. This is a no-op.');\n    }\n  };\n\n  return {\n    error: error,\n    ready: ready,\n    submit: plaid ? plaid.submit : noop,\n    exit: plaid ? plaid.exit : noop,\n    open: plaid ? plaid.open : openNoOp\n  };\n};\n\nvar _excluded = [\"children\", \"style\", \"className\"];\nvar PlaidLink = function PlaidLink(props) {\n  var children = props.children,\n      style = props.style,\n      className = props.className,\n      config = _objectWithoutProperties(props, _excluded);\n\n  var _usePlaidLink = usePlaidLink(_objectSpread2({}, config)),\n      error = _usePlaidLink.error,\n      open = _usePlaidLink.open;\n\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"button\", {\n    disabled: Boolean(error),\n    type: \"button\",\n    className: className,\n    style: _objectSpread2({\n      padding: '6px 4px',\n      outline: 'none',\n      background: '#FFFFFF',\n      border: '2px solid #F1F1F1',\n      borderRadius: '4px'\n    }, style),\n    onClick: function onClick() {\n      return open();\n    }\n  }, children);\n};\nPlaidLink.displayName = 'PlaidLink';\n\nvar PlaidEmbeddedLink = function PlaidEmbeddedLink(props) {\n  var style = props.style,\n      className = props.className,\n      onSuccess = props.onSuccess,\n      onExit = props.onExit,\n      onLoad = props.onLoad,\n      onEvent = props.onEvent,\n      token = props.token,\n      receivedRedirectUri = props.receivedRedirectUri;\n  var config = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {\n    return {\n      onSuccess: onSuccess,\n      onExit: onExit,\n      onLoad: onLoad,\n      onEvent: onEvent,\n      token: token,\n      receivedRedirectUri: receivedRedirectUri\n    };\n  }, [onSuccess, onExit, onLoad, onEvent, token, receivedRedirectUri]); // Asynchronously load the plaid/link/stable url into the DOM\n\n  var _useScript = useScript({\n    src: PLAID_LINK_STABLE_URL,\n    checkForExisting: true\n  }),\n      _useScript2 = _slicedToArray(_useScript, 2),\n      loading = _useScript2[0],\n      error = _useScript2[1];\n\n  var embeddedLinkTarget = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    // If the external link JS script is still loading, return prematurely\n    if (loading) {\n      return;\n    }\n\n    if (error || !window.Plaid) {\n      // eslint-disable-next-line no-console\n      console.error('Error loading Plaid', error);\n      return;\n    }\n\n    if (config.token == null || config.token == '') {\n      console.error('A token is required to initialize embedded Plaid Link');\n      return;\n    } // The embedded Link interface doesn't use the `usePlaidLink` hook to manage\n    // its Plaid Link instance because the embedded Link integration in link-initialize\n    // maintains its own handler internally.\n\n\n    var _window$Plaid$createE = window.Plaid.createEmbedded(_objectSpread2({}, config), embeddedLinkTarget.current),\n        destroy = _window$Plaid$createE.destroy; // Clean up embedded Link component on unmount\n\n\n    return function () {\n      destroy();\n    };\n  }, [loading, error, config, embeddedLinkTarget]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    style: style,\n    className: className,\n    ref: embeddedLinkTarget\n  });\n};\n\n// The following event names are stable and will not be deprecated or changed\nvar PlaidLinkStableEvent;\n\n(function (PlaidLinkStableEvent) {\n  PlaidLinkStableEvent[\"OPEN\"] = \"OPEN\";\n  PlaidLinkStableEvent[\"EXIT\"] = \"EXIT\";\n  PlaidLinkStableEvent[\"HANDOFF\"] = \"HANDOFF\";\n  PlaidLinkStableEvent[\"SELECT_INSTITUTION\"] = \"SELECT_INSTITUTION\";\n  PlaidLinkStableEvent[\"ERROR\"] = \"ERROR\";\n  PlaidLinkStableEvent[\"BANK_INCOME_INSIGHTS_COMPLETED\"] = \"BANK_INCOME_INSIGHTS_COMPLETED\";\n  PlaidLinkStableEvent[\"IDENTITY_VERIFICATION_PASS_SESSION\"] = \"IDENTITY_VERIFICATION_PASS_SESSION\";\n  PlaidLinkStableEvent[\"IDENTITY_VERIFICATION_FAIL_SESSION\"] = \"IDENTITY_VERIFICATION_FAIL_SESSION\";\n})(PlaidLinkStableEvent || (PlaidLinkStableEvent = {}));\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGxhaWQtbGluay9kaXN0L2luZGV4LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBb0U7O0FBRXBFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNEJBQTRCLCtCQUErQjtBQUMzRDs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUNBQXlDLFNBQVM7O0FBRWxEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixhQUFhO0FBQ2hDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsNEhBQTRILGNBQWM7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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QUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDhDQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHFFQUFxRTs7QUFFeEU7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsNkNBQU07QUFDakMsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7OztBQUdBLDZFQUE2RTtBQUM3RSxpREFBaUQ7OztBQUdqRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsc0JBQXNCLDBEQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9EQUFvRDs7QUFFdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGxhaWQtbGluay9kaXN0L2luZGV4LmVzbS5qcz83ZDc1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VNZW1vLCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgIGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcblxuICB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG5cbiAgdmFyIGtleSwgaTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG59XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07XG5cbiAgaWYgKF9pID09IG51bGwpIHJldHVybjtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG5cbiAgdmFyIF9zLCBfZTtcblxuICB0cnkge1xuICAgIGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICByZXR1cm4gYXJyMjtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxudmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbmZ1bmN0aW9uIHVud3JhcEV4cG9ydHMgKHgpIHtcblx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUoZm4sIG1vZHVsZSkge1xuXHRyZXR1cm4gbW9kdWxlID0geyBleHBvcnRzOiB7fSB9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG59XG5cbnZhciB1c2VTY3JpcHRfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIF9fcmVzdCA9IGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fcmVzdCB8fCBmdW5jdGlvbiAocywgZSkge1xuICB2YXIgdCA9IHt9O1xuXG4gIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKSB0W3BdID0gc1twXTtcblxuICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpIHRbcFtpXV0gPSBzW3BbaV1dO1xuICB9XG4gIHJldHVybiB0O1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc2NyaXB0cyA9IHZvaWQgMDtcblxuIC8vIFByZXZpb3VzbHkgbG9hZGluZy9sb2FkZWQgc2NyaXB0cyBhbmQgdGhlaXIgY3VycmVudCBzdGF0dXNcblxuXG5leHBvcnRzLnNjcmlwdHMgPSB7fTsgLy8gQ2hlY2sgZm9yIGV4aXN0aW5nIDxzY3JpcHQ+IHRhZ3Mgd2l0aCB0aGlzIHNyYy4gSWYgc28sIHVwZGF0ZSBzY3JpcHRzW3NyY11cbi8vIGFuZCByZXR1cm4gdGhlIG5ldyBzdGF0dXM7IG90aGVyd2lzZSwgcmV0dXJuIHVuZGVmaW5lZC5cblxudmFyIGNoZWNrRXhpc3RpbmcgPSBmdW5jdGlvbiAoc3JjKSB7XG4gIHZhciBleGlzdGluZyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJzY3JpcHRbc3JjPVxcXCJcIiArIHNyYyArIFwiXFxcIl1cIik7XG5cbiAgaWYgKGV4aXN0aW5nKSB7XG4gICAgLy8gQXNzdW1lIGV4aXN0aW5nIDxzY3JpcHQ+IHRhZyBpcyBhbHJlYWR5IGxvYWRlZCxcbiAgICAvLyBhbmQgY2FjaGUgdGhhdCBkYXRhIGZvciBmdXR1cmUgdXNlLlxuICAgIHJldHVybiBleHBvcnRzLnNjcmlwdHNbc3JjXSA9IHtcbiAgICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAgZXJyb3I6IG51bGwsXG4gICAgICBzY3JpcHRFbDogZXhpc3RpbmdcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbmZ1bmN0aW9uIHVzZVNjcmlwdChfYSkge1xuICB2YXIgc3JjID0gX2Euc3JjLFxuICAgICAgX2IgPSBfYS5jaGVja0ZvckV4aXN0aW5nLFxuICAgICAgY2hlY2tGb3JFeGlzdGluZyA9IF9iID09PSB2b2lkIDAgPyBmYWxzZSA6IF9iLFxuICAgICAgYXR0cmlidXRlcyA9IF9fcmVzdChfYSwgW1wic3JjXCIsIFwiY2hlY2tGb3JFeGlzdGluZ1wiXSk7IC8vIENoZWNrIHdoZXRoZXIgc29tZSBpbnN0YW5jZSBvZiB0aGlzIGhvb2sgY29uc2lkZXJlZCB0aGlzIHNyYy5cblxuXG4gIHZhciBzdGF0dXMgPSBzcmMgPyBleHBvcnRzLnNjcmlwdHNbc3JjXSA6IHVuZGVmaW5lZDsgLy8gSWYgcmVxdWVzdGVkLCBjaGVjayBmb3IgZXhpc3RpbmcgPHNjcmlwdD4gdGFncyB3aXRoIHRoaXMgc3JjXG4gIC8vICh1bmxlc3Mgd2UndmUgYWxyZWFkeSBsb2FkZWQgdGhlIHNjcmlwdCBvdXJzZWx2ZXMpLlxuXG4gIGlmICghc3RhdHVzICYmIGNoZWNrRm9yRXhpc3RpbmcgJiYgc3JjICYmIGlzQnJvd3Nlcikge1xuICAgIHN0YXR1cyA9IGNoZWNrRXhpc3Rpbmcoc3JjKTtcbiAgfVxuXG4gIHZhciBfYyA9ICgwLCBSZWFjdC51c2VTdGF0ZSkoc3RhdHVzID8gc3RhdHVzLmxvYWRpbmcgOiBCb29sZWFuKHNyYykpLFxuICAgICAgbG9hZGluZyA9IF9jWzBdLFxuICAgICAgc2V0TG9hZGluZyA9IF9jWzFdO1xuXG4gIHZhciBfZCA9ICgwLCBSZWFjdC51c2VTdGF0ZSkoc3RhdHVzID8gc3RhdHVzLmVycm9yIDogbnVsbCksXG4gICAgICBlcnJvciA9IF9kWzBdLFxuICAgICAgc2V0RXJyb3IgPSBfZFsxXTtcblxuICAoMCwgUmVhY3QudXNlRWZmZWN0KShmdW5jdGlvbiAoKSB7XG4gICAgLy8gTm90aGluZyB0byBkbyBvbiBzZXJ2ZXIsIG9yIGlmIG5vIHNyYyBzcGVjaWZpZWQsIG9yXG4gICAgLy8gaWYgbG9hZGluZyBoYXMgYWxyZWFkeSByZXNvbHZlZCB0byBcImxvYWRlZFwiIG9yIFwiZXJyb3JcIiBzdGF0ZS5cbiAgICBpZiAoIWlzQnJvd3NlciB8fCAhc3JjIHx8ICFsb2FkaW5nIHx8IGVycm9yKSByZXR1cm47IC8vIENoZWNrIGFnYWluIGZvciBleGlzdGluZyA8c2NyaXB0PiB0YWdzIHdpdGggdGhpcyBzcmNcbiAgICAvLyBpbiBjYXNlIGl0J3MgY2hhbmdlZCBzaW5jZSBtb3VudC5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG5cbiAgICBzdGF0dXMgPSBleHBvcnRzLnNjcmlwdHNbc3JjXTtcblxuICAgIGlmICghc3RhdHVzICYmIGNoZWNrRm9yRXhpc3RpbmcpIHtcbiAgICAgIHN0YXR1cyA9IGNoZWNrRXhpc3Rpbmcoc3JjKTtcbiAgICB9IC8vIERldGVybWluZSBvciBjcmVhdGUgPHNjcmlwdD4gZWxlbWVudCB0byBsaXN0ZW4gdG8uXG5cblxuICAgIHZhciBzY3JpcHRFbDtcblxuICAgIGlmIChzdGF0dXMpIHtcbiAgICAgIHNjcmlwdEVsID0gc3RhdHVzLnNjcmlwdEVsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY3JpcHRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgc2NyaXB0RWwuc3JjID0gc3JjO1xuICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmIChzY3JpcHRFbFtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzY3JpcHRFbC5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjcmlwdEVsW2tleV0gPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgc3RhdHVzID0gZXhwb3J0cy5zY3JpcHRzW3NyY10gPSB7XG4gICAgICAgIGxvYWRpbmc6IHRydWUsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICBzY3JpcHRFbDogc2NyaXB0RWxcbiAgICAgIH07XG4gICAgfSAvLyBgc3RhdHVzYCBpcyBub3cgZ3VhcmFudGVlZCB0byBiZSBkZWZpbmVkOiBlaXRoZXIgdGhlIG9sZCBzdGF0dXNcbiAgICAvLyBmcm9tIGEgcHJldmlvdXMgbG9hZCwgb3IgYSBuZXdseSBjcmVhdGVkIG9uZS5cblxuXG4gICAgdmFyIGhhbmRsZUxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc3RhdHVzKSBzdGF0dXMubG9hZGluZyA9IGZhbHNlO1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgfTtcblxuICAgIHZhciBoYW5kbGVFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgaWYgKHN0YXR1cykgc3RhdHVzLmVycm9yID0gZXJyb3I7XG4gICAgICBzZXRFcnJvcihlcnJvcik7XG4gICAgfTtcblxuICAgIHNjcmlwdEVsLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBoYW5kbGVMb2FkKTtcbiAgICBzY3JpcHRFbC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGhhbmRsZUVycm9yKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdEVsKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgc2NyaXB0RWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIGhhbmRsZUxvYWQpO1xuICAgICAgc2NyaXB0RWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVFcnJvcik7XG4gICAgfTsgLy8gd2UgbmVlZCB0byBpZ25vcmUgdGhlIGF0dHJpYnV0ZXMgYXMgdGhleSdyZSBhIG5ldyBvYmplY3QgcGVyIGNhbGwsIHNvIHdlJ2QgbmV2ZXIgc2tpcCBhbiBlZmZlY3QgY2FsbFxuICB9LCBbc3JjXSk7XG4gIHJldHVybiBbbG9hZGluZywgZXJyb3JdO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSB1c2VTY3JpcHQ7XG52YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG59KTtcblxudW53cmFwRXhwb3J0cyh1c2VTY3JpcHRfMSk7XG52YXIgdXNlU2NyaXB0XzIgPSB1c2VTY3JpcHRfMS5zY3JpcHRzO1xuXG52YXIgbGliID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgX19pbXBvcnREZWZhdWx0ID0gY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19pbXBvcnREZWZhdWx0IHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgcmV0dXJuIG1vZCAmJiBtb2QuX19lc01vZHVsZSA/IG1vZCA6IHtcbiAgICBcImRlZmF1bHRcIjogbW9kXG4gIH07XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5zY3JpcHRzID0gZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVmYXVsdFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfX2ltcG9ydERlZmF1bHQodXNlU2NyaXB0XzEpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2NyaXB0c1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB1c2VTY3JpcHRfMS5zY3JpcHRzO1xuICB9XG59KTtcbn0pO1xuXG52YXIgdXNlU2NyaXB0ID0gdW53cmFwRXhwb3J0cyhsaWIpO1xudmFyIGxpYl8xID0gbGliLnNjcmlwdHM7XG5cbnZhciByZW5hbWVLZXlJbk9iamVjdCA9IGZ1bmN0aW9uIHJlbmFtZUtleUluT2JqZWN0KG8sIG9sZEtleSwgbmV3S2V5KSB7XG4gIHZhciBuZXdPYmplY3QgPSB7fTtcbiAgZGVsZXRlIE9iamVjdC5hc3NpZ24obmV3T2JqZWN0LCBvLCBfZGVmaW5lUHJvcGVydHkoe30sIG5ld0tleSwgb1tvbGRLZXldKSlbb2xkS2V5XTtcbiAgcmV0dXJuIG5ld09iamVjdDtcbn07XG4vKipcbiAqIFdyYXAgbGluayBoYW5kbGVyIGNyZWF0aW9uIGFuZCBpbnN0YW5jZSB0byBjbGVhbiB1cCBpZnJhbWUgdmlhIGRlc3Ryb3koKSBtZXRob2RcbiAqL1xuXG5cbnZhciBjcmVhdGVQbGFpZEhhbmRsZXIgPSBmdW5jdGlvbiBjcmVhdGVQbGFpZEhhbmRsZXIoY29uZmlnLCBjcmVhdG9yKSB7XG4gIHZhciBzdGF0ZSA9IHtcbiAgICBwbGFpZDogbnVsbCxcbiAgICBvcGVuOiBmYWxzZSxcbiAgICBvbkV4aXRDYWxsYmFjazogbnVsbFxuICB9OyAvLyBJZiBQbGFpZCBpcyBub3QgYXZhaWxhYmxlLCB0aHJvdyBhbiBFcnJvclxuXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhd2luZG93LlBsYWlkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQbGFpZCBub3QgbG9hZGVkJyk7XG4gIH1cblxuICBzdGF0ZS5wbGFpZCA9IGNyZWF0b3IoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGNvbmZpZyksIHt9LCB7XG4gICAgb25FeGl0OiBmdW5jdGlvbiBvbkV4aXQoZXJyb3IsIG1ldGFkYXRhKSB7XG4gICAgICBzdGF0ZS5vcGVuID0gZmFsc2U7XG4gICAgICBjb25maWcub25FeGl0ICYmIGNvbmZpZy5vbkV4aXQoZXJyb3IsIG1ldGFkYXRhKTtcbiAgICAgIHN0YXRlLm9uRXhpdENhbGxiYWNrICYmIHN0YXRlLm9uRXhpdENhbGxiYWNrKCk7XG4gICAgfVxuICB9KSk7XG5cbiAgdmFyIG9wZW4gPSBmdW5jdGlvbiBvcGVuKCkge1xuICAgIGlmICghc3RhdGUucGxhaWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzdGF0ZS5vcGVuID0gdHJ1ZTtcbiAgICBzdGF0ZS5vbkV4aXRDYWxsYmFjayA9IG51bGw7XG4gICAgc3RhdGUucGxhaWQub3BlbigpO1xuICB9O1xuXG4gIHZhciBzdWJtaXQgPSBmdW5jdGlvbiBzdWJtaXQoZGF0YSkge1xuICAgIGlmICghc3RhdGUucGxhaWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzdGF0ZS5wbGFpZC5zdWJtaXQoZGF0YSk7XG4gIH07XG5cbiAgdmFyIGV4aXQgPSBmdW5jdGlvbiBleGl0KGV4aXRPcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGlmICghc3RhdGUub3BlbiB8fCAhc3RhdGUucGxhaWQpIHtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3RhdGUub25FeGl0Q2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICBzdGF0ZS5wbGFpZC5leGl0KGV4aXRPcHRpb25zKTtcblxuICAgIGlmIChleGl0T3B0aW9ucyAmJiBleGl0T3B0aW9ucy5mb3JjZSkge1xuICAgICAgc3RhdGUub3BlbiA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgaWYgKCFzdGF0ZS5wbGFpZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN0YXRlLnBsYWlkLmRlc3Ryb3koKTtcbiAgICBzdGF0ZS5wbGFpZCA9IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBvcGVuOiBvcGVuLFxuICAgIHN1Ym1pdDogc3VibWl0LFxuICAgIGV4aXQ6IGV4aXQsXG4gICAgZGVzdHJveTogZGVzdHJveVxuICB9O1xufTtcbnZhciBjcmVhdGVQbGFpZCA9IGZ1bmN0aW9uIGNyZWF0ZVBsYWlkKG9wdGlvbnMsIGNyZWF0b3IpIHtcbiAgdmFyIGNvbmZpZyA9IHJlbmFtZUtleUluT2JqZWN0KG9wdGlvbnMsICdwdWJsaWNLZXknLCAna2V5Jyk7XG4gIHJldHVybiBjcmVhdGVQbGFpZEhhbmRsZXIoY29uZmlnLCBjcmVhdG9yKTtcbn07XG5cbnZhciBQTEFJRF9MSU5LX1NUQUJMRV9VUkwgPSAnaHR0cHM6Ly9jZG4ucGxhaWQuY29tL2xpbmsvdjIvc3RhYmxlL2xpbmstaW5pdGlhbGl6ZS5qcyc7XG5cbnZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuLyoqXG4gKiBUaGlzIGhvb2sgbG9hZHMgUGxhaWQgc2NyaXB0IGFuZCBtYW5hZ2VzIHRoZSBQbGFpZCBMaW5rIGNyZWF0aW9uIGZvciB5b3UuXG4gKiBZb3UgZ2V0IGVhc3kgb3BlbiAmIGV4aXQgbWV0aG9kcyB0byBjYWxsIGFuZCBsb2FkaW5nICYgZXJyb3Igc3RhdGVzLlxuICpcbiAqIFRoaXMgd2lsbCBkZXN0cm95IHRoZSBQbGFpZCBVSSBvbiB1bi1tb3VudGluZyBzbyBpdCdzIHVwIHRvIHlvdSB0byBiZVxuICogZ3JhY2VmdWwgdG8gdGhlIHVzZXIuXG4gKlxuICogQSBuZXcgUGxhaWQgaW5zdGFuY2UgaXMgY3JlYXRlZCBldmVyeSB0aW1lIHRoZSB0b2tlbiBhbmQgcHJvZHVjdHMgb3B0aW9ucyBjaGFuZ2UuXG4gKiBJdCdzIHVwIHRvIHlvdSB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IHJlLWNyZWF0aW9ucyBvbiByZS1yZW5kZXIuXG4gKi9cblxuXG52YXIgdXNlUGxhaWRMaW5rID0gZnVuY3Rpb24gdXNlUGxhaWRMaW5rKG9wdGlvbnMpIHtcbiAgLy8gQXN5bmNocm9ub3VzbHkgbG9hZCB0aGUgcGxhaWQvbGluay9zdGFibGUgdXJsIGludG8gdGhlIERPTVxuICB2YXIgX3VzZVNjcmlwdCA9IHVzZVNjcmlwdCh7XG4gICAgc3JjOiBQTEFJRF9MSU5LX1NUQUJMRV9VUkwsXG4gICAgY2hlY2tGb3JFeGlzdGluZzogdHJ1ZVxuICB9KSxcbiAgICAgIF91c2VTY3JpcHQyID0gX3NsaWNlZFRvQXJyYXkoX3VzZVNjcmlwdCwgMiksXG4gICAgICBsb2FkaW5nID0gX3VzZVNjcmlwdDJbMF0sXG4gICAgICBlcnJvciA9IF91c2VTY3JpcHQyWzFdOyAvLyBpbnRlcm5hbCBzdGF0ZVxuXG5cbiAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKG51bGwpLFxuICAgICAgX3VzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZSwgMiksXG4gICAgICBwbGFpZCA9IF91c2VTdGF0ZTJbMF0sXG4gICAgICBzZXRQbGFpZCA9IF91c2VTdGF0ZTJbMV07XG5cbiAgdmFyIF91c2VTdGF0ZTMgPSB1c2VTdGF0ZShmYWxzZSksXG4gICAgICBfdXNlU3RhdGU0ID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlMywgMiksXG4gICAgICBpZnJhbWVMb2FkZWQgPSBfdXNlU3RhdGU0WzBdLFxuICAgICAgc2V0SWZyYW1lTG9hZGVkID0gX3VzZVN0YXRlNFsxXTtcblxuICB2YXIgcHJvZHVjdHMgPSAob3B0aW9ucy5wcm9kdWN0IHx8IFtdKS5zbGljZSgpLnNvcnQoKS5qb2luKCcsJyk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgLy8gSWYgdGhlIGxpbmsuanMgc2NyaXB0IGlzIHN0aWxsIGxvYWRpbmcsIHJldHVybiBwcmVtYXR1cmVseVxuICAgIGlmIChsb2FkaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBJZiB0aGUgdG9rZW4sIHB1YmxpY0tleSwgYW5kIHJlY2VpdmVkIHJlZGlyZWN0IFVSSSBhcmUgdW5kZWZpbmVkLCByZXR1cm4gcHJlbWF0dXJlbHlcblxuXG4gICAgaWYgKCFvcHRpb25zLnRva2VuICYmICFvcHRpb25zLnB1YmxpY0tleSAmJiAhb3B0aW9ucy5yZWNlaXZlZFJlZGlyZWN0VXJpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVycm9yIHx8ICF3aW5kb3cuUGxhaWQpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIFBsYWlkJywgZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gaWYgYW4gb2xkIHBsYWlkIGluc3RhbmNlIGV4aXN0cywgZGVzdHJveSBpdCBiZWZvcmVcbiAgICAvLyBjcmVhdGluZyBhIG5ldyBvbmVcblxuXG4gICAgaWYgKHBsYWlkICE9IG51bGwpIHtcbiAgICAgIHBsYWlkLmV4aXQoe1xuICAgICAgICBmb3JjZTogdHJ1ZVxuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcGxhaWQuZGVzdHJveSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIG5leHQgPSBjcmVhdGVQbGFpZChfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICBvbkxvYWQ6IGZ1bmN0aW9uIG9uTG9hZCgpIHtcbiAgICAgICAgc2V0SWZyYW1lTG9hZGVkKHRydWUpO1xuICAgICAgICBvcHRpb25zLm9uTG9hZCAmJiBvcHRpb25zLm9uTG9hZCgpO1xuICAgICAgfVxuICAgIH0pLCB3aW5kb3cuUGxhaWQuY3JlYXRlKTtcbiAgICBzZXRQbGFpZChuZXh0KTsgLy8gZGVzdHJveSB0aGUgUGxhaWQgaWZyYW1lIGZhY3RvcnlcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV4dC5leGl0KHtcbiAgICAgICAgZm9yY2U6IHRydWVcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5leHQuZGVzdHJveSgpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSwgW2xvYWRpbmcsIGVycm9yLCBvcHRpb25zLnB1YmxpY0tleSwgb3B0aW9ucy50b2tlbiwgcHJvZHVjdHNdKTtcbiAgdmFyIHJlYWR5ID0gcGxhaWQgIT0gbnVsbCAmJiAoIWxvYWRpbmcgfHwgaWZyYW1lTG9hZGVkKTtcblxuICB2YXIgb3Blbk5vT3AgPSBmdW5jdGlvbiBvcGVuTm9PcCgpIHtcbiAgICBpZiAoIW9wdGlvbnMudG9rZW4pIHtcbiAgICAgIGNvbnNvbGUud2FybigncmVhY3QtcGxhaWQtbGluazogWW91IGNhbm5vdCBjYWxsIG9wZW4oKSB3aXRob3V0IGEgdmFsaWQgdG9rZW4gc3VwcGxpZWQgdG8gdXNlUGxhaWRMaW5rLiBUaGlzIGlzIGEgbm8tb3AuJyk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgZXJyb3I6IGVycm9yLFxuICAgIHJlYWR5OiByZWFkeSxcbiAgICBzdWJtaXQ6IHBsYWlkID8gcGxhaWQuc3VibWl0IDogbm9vcCxcbiAgICBleGl0OiBwbGFpZCA/IHBsYWlkLmV4aXQgOiBub29wLFxuICAgIG9wZW46IHBsYWlkID8gcGxhaWQub3BlbiA6IG9wZW5Ob09wXG4gIH07XG59O1xuXG52YXIgX2V4Y2x1ZGVkID0gW1wiY2hpbGRyZW5cIiwgXCJzdHlsZVwiLCBcImNsYXNzTmFtZVwiXTtcbnZhciBQbGFpZExpbmsgPSBmdW5jdGlvbiBQbGFpZExpbmsocHJvcHMpIHtcbiAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBzdHlsZSA9IHByb3BzLnN0eWxlLFxuICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgY29uZmlnID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBfZXhjbHVkZWQpO1xuXG4gIHZhciBfdXNlUGxhaWRMaW5rID0gdXNlUGxhaWRMaW5rKF9vYmplY3RTcHJlYWQyKHt9LCBjb25maWcpKSxcbiAgICAgIGVycm9yID0gX3VzZVBsYWlkTGluay5lcnJvcixcbiAgICAgIG9wZW4gPSBfdXNlUGxhaWRMaW5rLm9wZW47XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHtcbiAgICBkaXNhYmxlZDogQm9vbGVhbihlcnJvciksXG4gICAgdHlwZTogXCJidXR0b25cIixcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICBzdHlsZTogX29iamVjdFNwcmVhZDIoe1xuICAgICAgcGFkZGluZzogJzZweCA0cHgnLFxuICAgICAgb3V0bGluZTogJ25vbmUnLFxuICAgICAgYmFja2dyb3VuZDogJyNGRkZGRkYnLFxuICAgICAgYm9yZGVyOiAnMnB4IHNvbGlkICNGMUYxRjEnLFxuICAgICAgYm9yZGVyUmFkaXVzOiAnNHB4J1xuICAgIH0sIHN0eWxlKSxcbiAgICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKCkge1xuICAgICAgcmV0dXJuIG9wZW4oKTtcbiAgICB9XG4gIH0sIGNoaWxkcmVuKTtcbn07XG5QbGFpZExpbmsuZGlzcGxheU5hbWUgPSAnUGxhaWRMaW5rJztcblxudmFyIFBsYWlkRW1iZWRkZWRMaW5rID0gZnVuY3Rpb24gUGxhaWRFbWJlZGRlZExpbmsocHJvcHMpIHtcbiAgdmFyIHN0eWxlID0gcHJvcHMuc3R5bGUsXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBvblN1Y2Nlc3MgPSBwcm9wcy5vblN1Y2Nlc3MsXG4gICAgICBvbkV4aXQgPSBwcm9wcy5vbkV4aXQsXG4gICAgICBvbkxvYWQgPSBwcm9wcy5vbkxvYWQsXG4gICAgICBvbkV2ZW50ID0gcHJvcHMub25FdmVudCxcbiAgICAgIHRva2VuID0gcHJvcHMudG9rZW4sXG4gICAgICByZWNlaXZlZFJlZGlyZWN0VXJpID0gcHJvcHMucmVjZWl2ZWRSZWRpcmVjdFVyaTtcbiAgdmFyIGNvbmZpZyA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvblN1Y2Nlc3M6IG9uU3VjY2VzcyxcbiAgICAgIG9uRXhpdDogb25FeGl0LFxuICAgICAgb25Mb2FkOiBvbkxvYWQsXG4gICAgICBvbkV2ZW50OiBvbkV2ZW50LFxuICAgICAgdG9rZW46IHRva2VuLFxuICAgICAgcmVjZWl2ZWRSZWRpcmVjdFVyaTogcmVjZWl2ZWRSZWRpcmVjdFVyaVxuICAgIH07XG4gIH0sIFtvblN1Y2Nlc3MsIG9uRXhpdCwgb25Mb2FkLCBvbkV2ZW50LCB0b2tlbiwgcmVjZWl2ZWRSZWRpcmVjdFVyaV0pOyAvLyBBc3luY2hyb25vdXNseSBsb2FkIHRoZSBwbGFpZC9saW5rL3N0YWJsZSB1cmwgaW50byB0aGUgRE9NXG5cbiAgdmFyIF91c2VTY3JpcHQgPSB1c2VTY3JpcHQoe1xuICAgIHNyYzogUExBSURfTElOS19TVEFCTEVfVVJMLFxuICAgIGNoZWNrRm9yRXhpc3Rpbmc6IHRydWVcbiAgfSksXG4gICAgICBfdXNlU2NyaXB0MiA9IF9zbGljZWRUb0FycmF5KF91c2VTY3JpcHQsIDIpLFxuICAgICAgbG9hZGluZyA9IF91c2VTY3JpcHQyWzBdLFxuICAgICAgZXJyb3IgPSBfdXNlU2NyaXB0MlsxXTtcblxuICB2YXIgZW1iZWRkZWRMaW5rVGFyZ2V0ID0gdXNlUmVmKG51bGwpO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIC8vIElmIHRoZSBleHRlcm5hbCBsaW5rIEpTIHNjcmlwdCBpcyBzdGlsbCBsb2FkaW5nLCByZXR1cm4gcHJlbWF0dXJlbHlcbiAgICBpZiAobG9hZGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlcnJvciB8fCAhd2luZG93LlBsYWlkKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBQbGFpZCcsIGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLnRva2VuID09IG51bGwgfHwgY29uZmlnLnRva2VuID09ICcnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdBIHRva2VuIGlzIHJlcXVpcmVkIHRvIGluaXRpYWxpemUgZW1iZWRkZWQgUGxhaWQgTGluaycpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gVGhlIGVtYmVkZGVkIExpbmsgaW50ZXJmYWNlIGRvZXNuJ3QgdXNlIHRoZSBgdXNlUGxhaWRMaW5rYCBob29rIHRvIG1hbmFnZVxuICAgIC8vIGl0cyBQbGFpZCBMaW5rIGluc3RhbmNlIGJlY2F1c2UgdGhlIGVtYmVkZGVkIExpbmsgaW50ZWdyYXRpb24gaW4gbGluay1pbml0aWFsaXplXG4gICAgLy8gbWFpbnRhaW5zIGl0cyBvd24gaGFuZGxlciBpbnRlcm5hbGx5LlxuXG5cbiAgICB2YXIgX3dpbmRvdyRQbGFpZCRjcmVhdGVFID0gd2luZG93LlBsYWlkLmNyZWF0ZUVtYmVkZGVkKF9vYmplY3RTcHJlYWQyKHt9LCBjb25maWcpLCBlbWJlZGRlZExpbmtUYXJnZXQuY3VycmVudCksXG4gICAgICAgIGRlc3Ryb3kgPSBfd2luZG93JFBsYWlkJGNyZWF0ZUUuZGVzdHJveTsgLy8gQ2xlYW4gdXAgZW1iZWRkZWQgTGluayBjb21wb25lbnQgb24gdW5tb3VudFxuXG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZGVzdHJveSgpO1xuICAgIH07XG4gIH0sIFtsb2FkaW5nLCBlcnJvciwgY29uZmlnLCBlbWJlZGRlZExpbmtUYXJnZXRdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgcmVmOiBlbWJlZGRlZExpbmtUYXJnZXRcbiAgfSk7XG59O1xuXG4vLyBUaGUgZm9sbG93aW5nIGV2ZW50IG5hbWVzIGFyZSBzdGFibGUgYW5kIHdpbGwgbm90IGJlIGRlcHJlY2F0ZWQgb3IgY2hhbmdlZFxudmFyIFBsYWlkTGlua1N0YWJsZUV2ZW50O1xuXG4oZnVuY3Rpb24gKFBsYWlkTGlua1N0YWJsZUV2ZW50KSB7XG4gIFBsYWlkTGlua1N0YWJsZUV2ZW50W1wiT1BFTlwiXSA9IFwiT1BFTlwiO1xuICBQbGFpZExpbmtTdGFibGVFdmVudFtcIkVYSVRcIl0gPSBcIkVYSVRcIjtcbiAgUGxhaWRMaW5rU3RhYmxlRXZlbnRbXCJIQU5ET0ZGXCJdID0gXCJIQU5ET0ZGXCI7XG4gIFBsYWlkTGlua1N0YWJsZUV2ZW50W1wiU0VMRUNUX0lOU1RJVFVUSU9OXCJdID0gXCJTRUxFQ1RfSU5TVElUVVRJT05cIjtcbiAgUGxhaWRMaW5rU3RhYmxlRXZlbnRbXCJFUlJPUlwiXSA9IFwiRVJST1JcIjtcbiAgUGxhaWRMaW5rU3RhYmxlRXZlbnRbXCJCQU5LX0lOQ09NRV9JTlNJR0hUU19DT01QTEVURURcIl0gPSBcIkJBTktfSU5DT01FX0lOU0lHSFRTX0NPTVBMRVRFRFwiO1xuICBQbGFpZExpbmtTdGFibGVFdmVudFtcIklERU5USVRZX1ZFUklGSUNBVElPTl9QQVNTX1NFU1NJT05cIl0gPSBcIklERU5USVRZX1ZFUklGSUNBVElPTl9QQVNTX1NFU1NJT05cIjtcbiAgUGxhaWRMaW5rU3RhYmxlRXZlbnRbXCJJREVOVElUWV9WRVJJRklDQVRJT05fRkFJTF9TRVNTSU9OXCJdID0gXCJJREVOVElUWV9WRVJJRklDQVRJT05fRkFJTF9TRVNTSU9OXCI7XG59KShQbGFpZExpbmtTdGFibGVFdmVudCB8fCAoUGxhaWRMaW5rU3RhYmxlRXZlbnQgPSB7fSkpO1xuXG5leHBvcnQgeyBQbGFpZEVtYmVkZGVkTGluaywgUGxhaWRMaW5rLCBQbGFpZExpbmtTdGFibGVFdmVudCwgdXNlUGxhaWRMaW5rIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-plaid-link/dist/index.esm.js\n");

/***/ })

};
;